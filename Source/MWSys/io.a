*
* File i/o system calls
*

 use ..../defs/os9defs.a
 psect io_a,0,0,2,0,0

* read(fd,buf,count)
read: pshs y
 ldx 6,s
 lda 5,s
 ldy 8,s
 pshs y save the count for later
 os9 I$READ

read1 bcc rdexit no problem if carry clear
 cmpb #E$EOF is the error EOF?
 bne read10 bra if not
 clra return zero bytes on EOF
 clrb
 puls x,y,pc

read10 puls x,y reset stack and data pointer
 lbra _os9err report error

rdexit tfr y,d return read/write count in d
 puls x,y,pc reset stack & data pointer and return

* readln(fildes,buffer,count)
readln: pshs y save data pointer
 lda 5,s get path number
 ldx 6,s get buffer address
 ldy 8,s get byte count

 pshs y save request for later
 os9 I$READLN call os9
 bra read1

* write(fd,buf,count)
write: pshs y save data pointer
 ldy 8,s get count
 beq write10
 lda 5,s get file number
 ldx 6,s get buffer address

 os9 I$WRITE

write1 bcc write10
 puls y
 lbra _os9err

write10 tfr y,d
 puls y,pc

* writeln(fildes,buffer,count)
writeln: pshs y save data pointer

 ldy 8,s get count
 beq write10
 lda 5,s get path number
 ldx 6,s get buffer address

 os9 I$WRITLN call os9
 bra write1

* lseek(fd,offset,type)
lseek: pshs u save the register variable
 ldd 10,s get type
 bne lseek10
 ldu #0
 ldx #0
 bra doseek

lseek10 cmpd #1 from here?
 beq here
 cmpd #2 from the end?
 beq end
* bad type
 ldb #E$SEEK

lserr clra
 std errno,y
 ldd #-1
 leax _flacc,y
 std 0,x
 std 2,x
 puls u,pc

* from the end
end lda 5,s get path number
 ldb #2 get file size code
 os9 I$GETSTT
 bcs lserr

 bra doseek

here lda 5,s
 ldb #5
 os9 I$GETSTT
 bcs lserr

doseek tfr u,d work on the LSW first
 addd 8,s
 std _flacc+2,y
 tfr d,u
 tfr x,d
 adcb 7,s
 adca 6,s
 bmi lserr seek is before beginning of file
 tfr d,x
 std _flacc,y

 lda 5,s path number
 os9 I$SEEK
 bcs lserr

 leax _flacc,y
 puls u,pc
 endsect
